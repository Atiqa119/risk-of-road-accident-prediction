# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EtQ-Q8EQHEL8qZAJLK6jcVvoYD1lht2O
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error

df = pd.read_csv("road_accident_risk_prediction.csv")

df

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
import pandas as pd
data = pd.read_csv("road_accident_risk_prediction.csv")
X=data[['Traffic_Volume', 'Speed_Limit', 'Speed_Violations', 'Number_of_Lanes',   'Visibility_Distance', 'Temperature',  'Past_Accident_Count',  'Emergency_Response_Time']] # Independent variables
y =data['Accident_Probability'] # Dependent variable
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2,
random_state=42)
model = LinearRegression()
model.fit(X_train, y_train)
predictions = model.predict(X_test)
print("MSE:", mean_squared_error(y_test, predictions))

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import LabelEncoder
import pandas as pd

# Load your dataset
data = pd.read_csv("road_accident_risk_prediction.csv")

# Encode categorical variables (if any, such as 'Weather_Condition' or 'Road_Surface_Condition')
label_encoder = LabelEncoder()
data['Road_Type'] = label_encoder.fit_transform(data['Road_Type'])
data['Road_Surface_Condition'] = label_encoder.fit_transform(data['Road_Surface_Condition'])
data['Weather_Condition'] = label_encoder.fit_transform(data['Weather_Condition'])
data['Time_of_Day'] = label_encoder.fit_transform(data['Time_of_Day'])
data['Severity_of_Past_Accidents'] = label_encoder.fit_transform(data['Severity_of_Past_Accidents'])

# Define independent variables (features) and dependent variable (target)
X = data[['Traffic_Volume', 'Speed_Limit', 'Speed_Violations', 'Number_of_Lanes',
          'Road_Surface_Condition', 'Weather_Condition', 'Visibility_Distance',
          'Temperature', 'Time_of_Day', 'Past_Accident_Count', 'Severity_of_Past_Accidents',
          'Emergency_Response_Time']]  # Independent variables
y = data['Accident_Probability']  # Dependent variable (target)

# Split the data into training and testing sets (80% training, 20% testing)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialize and train the Linear Regression model
model = LinearRegression()
model.fit(X_train, y_train)

# Predict the target variable on the test set
predictions = model.predict(X_test)

# Evaluate the model's performance using Mean Squared Error
mse = mean_squared_error(y_test, predictions)
print("Mean Squared Error:", mse)

# Save Model
with open("linear_model.pkl", "wb") as file:
    pickle.dump(model, file)

!pip install streamlit

import streamlit as st
import numpy as np
import pickle

# Load trained model
model = pickle.load(open("linear_model.pkl", "rb"))

# Streamlit App UI
st.title("Road Accident Risk Prediction")
st.write("This is a simple Streamlit app for predicting accident risk.")

# User Inputs
road_type = st.selectbox("Road Type", ["Urban", "Rural", "Highway"])
traffic_volume = st.number_input("Traffic Volume (vehicles/hour):", min_value=0)
speed_limit = st.number_input("Speed Limit (km/h):", min_value=10)
speed_violations = st.number_input("Speed Violations (per day):", min_value=0)
num_lanes = st.number_input("Number of Lanes:", min_value=1)
road_surface = st.selectbox("Road Surface Condition", ["Dry", "Wet", "Icy"])
weather = st.selectbox("Weather Condition", ["Clear", "Rainy", "Foggy", "Snowy"])
visibility = st.number_input("Visibility Distance (meters):", min_value=0)
temperature = st.number_input("Temperature (Â°C):", min_value=-30, max_value=50)
time_of_day = st.selectbox("Time of Day", ["Morning", "Afternoon", "Evening", "Night"])
past_accidents = st.number_input("Past Accident Count:", min_value=0)
past_severity = st.number_input("Severity of Past Accidents (1-10):", min_value=1, max_value=10)
response_time = st.number_input("Emergency Response Time (minutes):", min_value=1)

# Encode categorical inputs as numerical (similar to training data)
road_type_map = {"Urban": 0, "Rural": 1, "Highway": 2}
road_surface_map = {"Dry": 0, "Wet": 1, "Icy": 2}
weather_map = {"Clear": 0, "Rainy": 1, "Foggy": 2, "Snowy": 3}
time_of_day_map = {"Morning": 0, "Afternoon": 1, "Evening": 2, "Night": 3}

# Convert categorical inputs to numerical
road_type_num = road_type_map[road_type]
road_surface_num = road_surface_map[road_surface]
weather_num = weather_map[weather]
time_of_day_num = time_of_day_map[time_of_day]

# Prediction Button
if st.button("Predict"):
    input_data = np.array([[road_type_num, traffic_volume, speed_limit, speed_violations,
                            num_lanes, road_surface_num, weather_num, visibility,
                            temperature, time_of_day_num, past_accidents, past_severity,
                            response_time]])

    prediction = model.predict(input_data)
    st.success(f"Predicted Accident Probability: {prediction[0]:.2f}")